# 1.4 재귀 알고리즘
[파이썬으로 쉽게 배우는 자료구조](https://www.booksr.co.kr/product/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/)를 보고 정리한 내용입니다. 스스로 이해한 부분들을 적었기 때문에 틀린부분이 있을 수 있습니다.
## 반복과 재귀
같은 일을 되풀이하는 방법에는 반복과 재귀가 있다.
* 반복(interation)
  * for 나 while 등의 반복문을 이용한다.
  * 보통은 수행속도가 빠르다.
  * 문제에 따라 프로그램 작성이 어려울 수 있다.

* 재귀(recursion)
  * 알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법
  * 함수 호출의 오버헤드가 있음
  * 간결한 코딩이 가능하다.

## 재귀가 적합한 경우
정의 자체가 순환적으로 되어 있는 문제나 자료구조
* 팩토리얼 구하기
* 피보나치 수열
* 이항 계수, 하노이 탑, 이진 탐색
## 팩토리얼 구하기
팩토리얼은 반복구조와 재귀구조로 나타낼 수 있다.   
대부분의 재귀는 반복문으로 바꾸어 작성할 수 있다.   

* 반복 구조
```python
def factorial_iter(n) :
    result = 1
    for k in range(1, n+1) :	
        result = result * k	
    return result
```
* 결과와 n의값을 계속 곱한다.
* 즉 시간 복잡도는 `O(n)`이다.
   
* 재귀 구조
```python
def factorial(n) :
    if n == 1 : 
        return 1
    else : 
        return n * factorial(n-1)
```
* n의 값이 입력되면 1이 아닐때 else로 실행되게 된다.
* 그렇게 되면 `factorial(n-1)`이 실행되게 되고 n의 값이 1이 될때 까지 반복되어 실행될 것이다.
* `factorial(1)`이 되게 되면 if문이 동작 하게 되어 1을 반환하게 된다.
* 그후 `factorial(2)`로 가게 되고 factorial(2) = `2*factorial(1)`이 되므로 2를 반환하게 된다.
* 또 앞에서 계산된 `factorial(2)`를 통해 `factorial(3)`을 계산하게 되고 목표값인 n까지 n번 반복하게 된다.
* 시간 복잡도는 n번 반복하므로 `O(n)`이 된다.

## 하노이 탑 문제
재귀문을 이용하는 문제중에는 대표적으로 하노이탑의 문제가 있다.   
하노이 탑은 세게의 막대를 이용하여 왼쪽의 탑을 오른쪽의 탑으로 옮기는 문제이다.
![20250114_210606](https://github.com/user-attachments/assets/795c1fde-138a-40a6-9a8b-e166ae61bf7b)

### 함수 구현

```python
def hanoi_tower(n,fr,tmp,to):
  if (n=1):
    print("원판 1 %s --> %s"%(fr,to))
  else:
    hanoi_tower(n-1,fr,to,tmp)
    print("원판 %d : %s --> %s"%(n,fr,to))
    hanoi_tower(n-1,tmp,fr,to)
```
### 함수 해설
* 하노이 탑을 한쪽으로 모두 옮기기 위해서는 제일 밑의 블럭 한개를 제외한 위의 모든 블럭을 중간으로 보낸 후 제일 밑의 블럭을 제일 오른쪽의 막대에 꽂아야 한다.
* 그후 중간에 있는 탑들을 다시 순서대로 제일 오른쪽으로 옮기면 하노이 타워가 완성된다.
* `hanoi_tower(n,fr,tmp,to)`의 의미는 n개의 블럭을 `fr(제일 왼쪽)`에서 `tmp(가운데)`를 이용하여 `to(제일 오른쪽)`으로 이동시킨다는 의미이다. 함수 매개변수가 `hanoi_tower(블럭의 개수,시작지점,이용지점,목적지지점)`라는 것을 의미하는 것이다.
* 하노의 탑이 숫자가 3이라고 가정하면 `n=3`이기 때문에 `else문`을 이용하게 된다.
* 그러면 첫번째 재귀함수를 만나게 되어 `hanoi_tower(n-1,fr,to,tmp)`를 사용하게 되는데 이는 제일 밑을 제외한 위의 두개블럭(n-1)을 `fr(제일 왼쪽)`에서 `to(제일 오른쪽)`을 이용하여 `tmp(가운데)`로 옮기는 것을 이야기 한다.
* 위의 2개의 블럭을 가운데로 옮기면 제일 왼쪽에는 가장 아래의 블럭이 남기 때문에 `print("원판 %d : %s --> %s"%(n,fr,to))`을 통하여 `제일 밑(n번째)`, 즉 3번째 블럭을 `fr(제일 왼쪽)`, `to(제일 오른쪽)`로 옮긴다.
* 그후 다시 제일 밑의`hanoi_tower(n-1,tmp,fr,to)` 재귀함수를 이용하여 `tmp(가운데)`에 모아놨던 두개의 블럭을 `fr(제일 왼쪽)`을 이용하여 `to(제일 오른쪽)`로 옮기는 방식이다.
