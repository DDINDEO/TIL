# 1.3 알고리즘의 성능
[파이썬으로 쉽게 배우는 자료구조](https://www.booksr.co.kr/product/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/)를 보고 정리한 내용입니다.

# 알고리즘의 성능 분석
알고리즘의 성능을 분석하는 방법에는 실행시간 측정방식을 통해 분석하는 방법과 복잡도를 계산하여 분석하는 방법이 있다.

## 실행시간 측정
* 알고리즘의 실제 시간을 측정을 하는 방법이다.
* 직접 측정하기 때문에 알고리즘을 구현을 해야 시간을 확인할 수 있다.
* 측정마다 같은 HW/SW환경을 사용해야 시간이 정확하다.

### 계산 예시
```python
def insert(bag, e) :
    bag.append(e)


# 실행시간 측정
import time

myBag = [ ]
start = time.time()

# Bag에 축구공을 100만번 삽입하는 코드
for _ in range(1000000) :
    insert(myBag, '축구공')

end = time.time()
print("실행시간 = ", end-start)
```
* 프로그램 실행시작시간과 종료시간의 차를 통하여 직접 계산하는 방식의 코드이다.

## 복잡도 분석

* 직접 구현을 하지 않아도 시간을 분석할 수 있다.
* 알고리즘의 연산 횟수를 대략적으로 계산을 한다.
* 복잡도 함수 T(n) : 입력의 크기 n에 대한 알고리즘 연산 횟수
  * 크기 n의 자료를 계산하기 위한 연산 횟수를 이야기 한다.
  * 예) 1부터 10까지의 덧셈을 반복문(for문)으로 실행하게 되면 10번 루프가 돌아가기 떄문에 T(n)은=10(번)이다.
* 복잡도의 분석에 따른 방식
  * 시간 복잡도 분석 : 수행 시간 분석
  * 공간 복잡도 분석 : 필요한 메모리 공간 분석

### 계산 예시
**알고리즘 1**
```python
def calc_sum1(n):
    sum = 0
    for i in range (n):
        sum = sum+i
    return sum
```
알고리즘 1의 함수에서 시간 복잡도 T(n)을 계산해 보면
* `sum = 0`에서 `=` 연산자가 한번 실행되기 때문에 `1`번 실행된다. 
* `for i in range (n)`안에 있는 `sum = sum+i`이 n번 실행되는데 `=`연산자와 `+`연산자가 있으므로 실행되는 횟수는 `2n`번이다.
* 즉 위에서 계산한것들을 모두 합치면 시간 복잡도 `T(n) = 2n+1`이 된다.
  
  
**알고리즘 2**
```python
def calc_sum2(n):
    sum = n*(n+1)/2
    return sum
```
알고리즘 2의 함수에서 시간 복잡도 T(n)을 계산해 보면
*`sum = n*(n+1)/2`에서 `=`,`*`,`+`,`/`가 각 한번씩 실행되기 때문에 시간복잡도 `T(n)=4` 이다.

시간 복잡도 T(n)의 계산을 통해 n이 무한대일때 알고리즘1은 T(n) = 2n+1으로 무한대가 되지만 알고리즘2는 T(n)=4으로 n이 없기 때문에 4로 계속 유지될 것이다.   
**즉, 알고리즘2가 알고리즘1보다 효율이 더 좋다는 것을 알 수 있다.**

## 점근적 표기
시간복잡도는 여러가지가 존재한다. 예를들어 위의 알고리즘의 n의값이 1이되면 알고리즘 1은 `T(1)=3`이 될것이고 알고리즘2는 `T(1)=4`가 될것이다. 즉 n의 값이 작을때는 알고리즘1이 더 효율적이라는 것이다.   
이와 같이 알고리즘이 입력의 크기에 따라 성능이 바뀌기 때문에 단순히 복잡도 함수의 최고차항만을 취해 표현하는 방식이다.
* n이 무한대에 가까워 지면 최고차항을 제외한 나머지의 영향력은 없는것이나 마찬가지이기 때문에 속도만을 표현하기 위한것이다.
* 점근적 상한/ 하한 / 동일등급이 있다
  * `빅 오`, `빅 오메가`, `빅 세타` 로 표현한다.

### 빅오 표기법
**O(g(n))**   
증가속도가 g(n)과 같거나 낮은 모든 함수를 포함한다.
* $3n^2 + 4n => O(n^2)$
* $2n-3 => O(n^2)$
* $n^3$은 $O(n^2)$이 아니다.
* 빅오 표기법은 어떠한 경우에도 g(n)에 비례하는 시간안에는 반드시 완료됨을 의미한다.

### 빅 오메가
**Ω(g(n))**   
처리시간의 하한이다. 차수가 같거나 높은 함수를 포함한다.   
* g(n)과 비례하는 시간보다 느린것을 의미한다.

### 빅 세타
**Θ(g(n))**   
상한이면서 하한 즉 같은 차수의 함수들만 포함되는 표기법이다.   
* g(n)과 비례하는 시간과 같음을 의미한다.

### 시간 복잡도 함수들의 증가속도
빅오의 함수의 크기가 클수록 n이 커질 때 마다 더 많은 시간이 걸리는 것을 알 수 있다.
![20250114_191346](https://github.com/user-attachments/assets/f50c8784-14ff-4cd9-9521-818a0d7e636e)

## 최선, 평균, 최악의 경우
실행시간은 입력의 집합에 따라 다를 수 있다. 각 경우마다 가지는 의미가 다르다.
* 최선의 경우 : 수행시간이 가장 빠른경우이다.
  * 예) 무작위로 놓여있는 일렬의 카드 중 맨 앞 순서에 원하는 카드가 있을 경우.
  * 계산이 가능하지만 의미가 없는 정보이다.
* 평균의 경우 : 수행시간이 평균적인 경우
  * 예) 무작위로 놓여있는 일렬의 카드중 중간에 원하는 카드가 있는 경우.
  * 계산하기 어렵다.
* **최악의 경우** : 수행시간이 가장 늦는 경우.
  * 예) 무작위로 놓여있는 일렬의 카드중 가장 마지막에 원하는 카드가 있는 경우.
  * 가장 널리 사용된다. 계산하기 쉽고 중요한 의미를 가진다.

## 복잡도 분석의 예
순차탐색 : 정렬되지 않은 배열에서 어떤 값을 찾는 알고리즘이다.    
배열이 정렬되지 않은 상태에서 앞에서 하나씩 항목을 찾게 될때
* 최선의 경우 : 맨 처음이 찾는 항목인 경우이다.
  * `T(n) = 1` -> `O(1)`
* 최악의 경우 : 맨 마지막에 있거나 배열에 찾는게 없는 경우이다.
  * `T(n) = n` -> `O(n)`
* 평균의 경우
  * 평균에 대한 정의를 가정해야 한다. : 배열의 숫자가 골고루 한번씩 모든 자리에 들어가는 경우
  * 찾는 값이 모든 자리에 한번씩 들어갈것 이므로 전체에서 중간을 찾는 공식을 사용하여 `T(n)=(n+1)/2` -> `O(n)`
